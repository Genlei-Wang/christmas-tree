<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas Tree</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ„</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Italianno&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            background: #050505;
            color: #D4AF37; /* å¥¢åé‡‘è‰² */
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        .title {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Italianno', cursive; /* æ‰‹å†™æ„Ÿè‰ºæœ¯å­—ä½“ */
            font-size: 48px; /* å¢å¤§å­—å· */
            font-weight: 400;
            color: #D4AF37; /* å¥¢åé‡‘è‰²ï¼Œé«˜è´µ */
            letter-spacing: 1px;
            text-shadow: 0 0 8px rgba(212, 175, 55, 0.4), 0 0 16px rgba(212, 175, 55, 0.2); /* å¾®å¼±å¤–å‘å…‰ */
            z-index: 10;
            pointer-events: none;
        }

        .camera-view {
            position: fixed;
            bottom: 120px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid rgba(212, 175, 55, 0.6); /* å¥¢åé‡‘è‰²è¾¹æ¡† */
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10;
            overflow: hidden;
        }

        .camera-view video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .gesture-sidebar {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(11, 16, 38, 0.7);
            padding: 15px;
            border-radius: 12px;
            z-index: 10;
            min-width: 160px;
        }

        .gesture-item {
            padding: 8px 10px;
            margin: 6px 0;
            border-radius: 6px;
            font-size: 13px;
            font-family: 'Outfit', sans-serif;
            color: #C9A961; /* é¦™æ§Ÿé‡‘è‰²ï¼Œå¥¢å */
            transition: all 0.3s;
            line-height: 1.4;
        }

        .gesture-item.active {
            background: rgba(212, 175, 55, 0.2);
            color: #D4AF37; /* å¥¢åé‡‘è‰² */
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .control-bar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }

        .btn-upload {
            height: 45px;
            padding: 0 18px;
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 22.5px;
            color: #D4AF37; /* å¥¢åé‡‘è‰² */
            font-family: 'Outfit', sans-serif;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
        }

        .btn-upload:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }

        .btn-music {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            color: #D4AF37; /* å¥¢åé‡‘è‰² */
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .btn-music:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #050505;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(212, 175, 55, 0.2);
            border-top-color: #D4AF37; /* å¥¢åé‡‘è‰² */
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: 'Outfit', sans-serif;
            color: #D4AF37; /* å¥¢åé‡‘è‰² */
            font-size: 18px;
        }

        #file-input {
            display: none;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading Magic...</div>
    </div>

    <div class="title">Merry Christmas</div>

    <div class="camera-view">
        <video id="video" autoplay playsinline></video>
    </div>

    <div class="gesture-sidebar">
        <div class="gesture-item" id="gestureFist">
            æ¡æ‹³ Â· èšåˆ
        </div>
        <div class="gesture-item" id="gestureOpen">
            å¼ å¼€ Â· æ•£å¼€
        </div>
        <div class="gesture-item" id="gesturePinch">
            æåˆ Â· æ”¾å¤§ç…§ç‰‡
        </div>
    </div>

    <div class="control-bar">
        <button class="btn-upload" id="btnUpload">
            <span>ğŸ“·</span>
            <span>ä¸Šä¼ ç…§ç‰‡</span>
        </button>
        <button class="btn-music" id="btnMusic">ğŸµ</button>
    </div>

    <input type="file" id="file-input" accept="image/*" multiple>

    <div id="canvas-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // é”™è¯¯å¤„ç†ï¼šå¿½ç•¥faviconç­‰éå…³é”®èµ„æºçš„404é”™è¯¯
        window.addEventListener('error', (event) => {
            if (event.target && (event.target.tagName === 'LINK' || event.target.tagName === 'IMG')) {
                const href = event.target.href || event.target.src || '';
                if (href.includes('favicon') || href.includes('icon')) {
                    return; // å¿½ç•¥faviconé”™è¯¯
                }
            }
        }, true);

        let THREE, EffectComposer, RenderPass, UnrealBloomPass;
        
        try {
            THREE = await import('three');
        } catch (error) {
            console.error('Failed to load Three.js:', error);
            const isFileProtocol = window.location.protocol === 'file:';
            if (isFileProtocol) {
                alert('æ— æ³•åŠ è½½Three.jsåº“ã€‚\n\nåŸå› ï¼šç›´æ¥æ‰“å¼€HTMLæ–‡ä»¶ï¼ˆfile://åè®®ï¼‰æ— æ³•åŠ è½½å¤–éƒ¨èµ„æºã€‚\n\nè§£å†³æ–¹æ¡ˆï¼š\n1. ä½¿ç”¨HTTPæœåŠ¡å™¨æ‰“å¼€ï¼ˆæ¨èï¼‰\n   - Windows: åŒå‡» start-server.bat\n   - Mac/Linux: è¿è¡Œ ./start-server.sh\n   - æˆ–æ‰‹åŠ¨è¿è¡Œ: python3 -m http.server 8000\n   - ç„¶åè®¿é—®: http://localhost:8000/ChristmasTree-sphere.html\n\n2. æˆ–è®¿é—®åœ¨çº¿ç‰ˆæœ¬ï¼ˆå¦‚æœå·²éƒ¨ç½²ï¼‰');
            } else {
                alert('æ— æ³•åŠ è½½Three.jsåº“ã€‚è¯·æ£€æŸ¥ï¼š\n1. ç½‘ç»œè¿æ¥\n2. é˜²ç«å¢™è®¾ç½®\n3. å¦‚æœåœ¨ä¸­å›½å¤§é™†ï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨VPN');
            }
            throw error;
        }

        try {
            const composerModule = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js');
            EffectComposer = composerModule.EffectComposer;
            
            const renderPassModule = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js');
            RenderPass = renderPassModule.RenderPass;
            
            const bloomPassModule = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js');
            UnrealBloomPass = bloomPassModule.UnrealBloomPass;
        } catch (error) {
            console.error('Failed to load postprocessing modules:', error);
            const isFileProtocol = window.location.protocol === 'file:';
            if (isFileProtocol) {
                alert('æ— æ³•åŠ è½½åå¤„ç†æ¨¡å—ã€‚\n\nè¯·ä½¿ç”¨HTTPæœåŠ¡å™¨æ‰“å¼€æ–‡ä»¶ï¼Œä¸è¦ç›´æ¥åŒå‡»HTMLæ–‡ä»¶ã€‚\n\nè¿è¡Œ start-server.bat (Windows) æˆ– start-server.sh (Mac/Linux)');
            } else {
                alert('æ— æ³•åŠ è½½åå¤„ç†æ¨¡å—ã€‚\né”™è¯¯ï¼š' + error.message + '\n\nè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œé˜²ç«å¢™è®¾ç½®');
            }
            throw error;
        }

        // å…¨å±€å˜é‡
        let scene, camera, renderer, composer;
        let particleSystem, ribbonSystem, starSystem, snowSystem, ornamentSystem;
        let photos = [];
        let currentGesture = 'fist';
        let isPinching = false;
        let focusedPhoto = null;
        let handLandmarker = null;
        let video = document.getElementById('video');
        let audioContext = null;
        let synth = null;
        let isPlaying = false;

        // åˆå§‹åŒ–åœºæ™¯
        function initScene() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x050505); // æ¢å¤é»‘è‰²èƒŒæ™¯
                scene.fog = new THREE.Fog(0x0B1026, 50, 200);

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 15);
                camera.lookAt(0, 0, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                // åå¤„ç†
                composer = new EffectComposer(renderer);
                const renderPass = new RenderPass(scene, camera);
                composer.addPass(renderPass);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.3, // strength - å¢å¼ºè¾‰å…‰ï¼Œè¥é€ ç”µå½±æ„Ÿ
                    0.55, // radius - ç¨å¾®å¢å¤§è¾‰å…‰åŠå¾„
                    0.7 // threshold - é™ä½é˜ˆå€¼ï¼Œè®©æ›´å¤šå…ƒç´ å‘å…‰
                );
                composer.addPass(bloomPass);

                // å…‰ç…§ - ä¼˜åŒ–å…‰ç…§ç³»ç»Ÿ
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.25); // é™ä½ç¯å¢ƒå…‰ï¼Œå¢å¼ºå¯¹æ¯”
                scene.add(ambientLight);
                
                // ä¸»å…‰æº - ä»ä¸Šæ–¹ç…§äº®æ ‘
                const mainLight = new THREE.DirectionalLight(0xFFD700, 0.8);
                mainLight.position.set(0, 15, 5);
                mainLight.castShadow = false;
                scene.add(mainLight);
                
                // è¡¥å…‰ - ä»å‰æ–¹ç…§äº®
                const fillLight = new THREE.PointLight(0xffdae0, 0.6, 100);
                fillLight.position.set(0, 5, 15);
                scene.add(fillLight);
                
                // èƒŒå…‰ - å¢å¼ºè½®å»“
                const backLight = new THREE.PointLight(0xE0E0E0, 0.4, 100);
                backLight.position.set(0, 8, -10);
                scene.add(backLight);
                
                // ä¸ºé¡¶éƒ¨å°çƒæ·»åŠ ä¸“ç”¨ç‚¹å…‰æºï¼Œå¢å¼º3Dæ•ˆæœ
                const starLight = new THREE.PointLight(0xFFD700, 1.5, 20);
                starLight.position.set(0, 7.25, 0); // ä¸å°çƒä½ç½®åŒæ­¥
                scene.add(starLight);
            } catch (e) {
                throw e;
            }
        }

        // åˆ›å»ºä¸»åœ£è¯æ ‘ç²’å­ - å¡«å……æ•´ä¸ªä¸‰è§’é”¥å½¢
        function createMainTree() {
            const particleCount = 6000; // å¤§å¹…å¢åŠ ç²’å­æ•°é‡ï¼Œå¡«å……æ•´ä¸ªä¸‰è§’é”¥å½¢
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            // é¢œè‰²å®šä¹‰ - ä¼˜åŒ–åçš„é¢œè‰²ä½“ç³»
            const white = new THREE.Color(0xFFFFFF); // ç™½è‰² - é«˜å…‰åŒº
            const lemonChiffon = new THREE.Color(0xFFFACD); // æŸ æª¬ç»¸è‰² - é«˜å…‰åŒº
            const champagneGold = new THREE.Color(0xF7E7CE); // é¦™æ§Ÿé‡‘ - ä¸­é—´åŒºä¸»ä½“
            const roseGold = new THREE.Color(0xE8B4B8); // ç«ç‘°é‡‘ - ä¸­é—´åŒºè¿‡æ¸¡
            const moonlightSilver = new THREE.Color(0xE0E0E0); // æœˆå…‰é“¶
            const warmGold = new THREE.Color(0xFFD700); // æš–é‡‘è‰²

            // ä¸‰è§’é”¥å½¢å‚æ•° - æ ‘å‘ä¸‹ç§»åŠ¨ï¼Œæ¢å¤åŸæ¥çš„è§’åº¦
            const maxHeight = 12;
            const baseRadius = 6; // æ¢å¤åŸæ¥çš„åº•éƒ¨åŠå¾„
            const topRadius = 0.1; // ç¨å¾®å¢å¤§é¡¶éƒ¨åŠå¾„ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„ç²’å­å½¢æˆå°–å°–
            const treeOffsetY = -5; // æ ‘å‘ä¸‹ç§»åŠ¨5ä¸ªå•ä½

            for (let i = 0; i < particleCount; i++) {
                // éšæœºé«˜åº¦ï¼Œä½†åº•éƒ¨å¯†åº¦æ›´é«˜ï¼Œé¡¶éƒ¨ä¹Ÿè¦æœ‰ç²’å­å½¢æˆå°–å°–
                const heightRandom = Math.pow(Math.random(), 1.2); // ä»1.3æ”¹ä¸º1.2ï¼Œå¢åŠ é¡¶éƒ¨ç²’å­å¯†åº¦
                const height = heightRandom * maxHeight + treeOffsetY;
                const t = (height - treeOffsetY) / maxHeight; // å½’ä¸€åŒ–é«˜åº¦ 0-1
                
                // æ ¹æ®é«˜åº¦è®¡ç®—è¯¥å±‚çš„æœ€å¤§åŠå¾„ï¼ˆä¸‰è§’é”¥å½¢ï¼‰
                const layerMaxRadius = topRadius + (baseRadius - topRadius) * (1 - t);
                
                // åœ¨åœ†å½¢åŒºåŸŸå†…éšæœºåˆ†å¸ƒï¼Œä½†ä¸­å¿ƒå¯†åº¦æ›´é«˜
                const angle = Math.random() * Math.PI * 2;
                // ä½¿ç”¨å¹³æ–¹æ ¹è®©ä¸­å¿ƒæ›´å¯†é›†ï¼Œä½†ä¸è¿‡åº¦èšé›†
                const radiusRandom = Math.sqrt(Math.random());
                const radius = radiusRandom * layerMaxRadius;
                
                // é¡¶éƒ¨åŒºåŸŸï¼ˆt > 0.9ï¼‰å‡å°‘éšæœºåç§»ï¼Œç¡®ä¿å½¢æˆå°–å°–
                let offsetX, offsetZ;
                if (t > 0.9) {
                    // é¡¶éƒ¨åŒºåŸŸï¼šå‡å°åç§»èŒƒå›´ï¼Œè®©ç²’å­æ›´é›†ä¸­åœ¨ä¸­å¿ƒ
                    offsetX = (Math.random() - 0.5) * 0.1;
                    offsetZ = (Math.random() - 0.5) * 0.1;
                } else {
                    // å…¶ä»–åŒºåŸŸï¼šæ­£å¸¸åç§»
                    offsetX = (Math.random() - 0.5) * 0.3;
                    offsetZ = (Math.random() - 0.5) * 0.3;
                }
                
                positions[i * 3] = Math.cos(angle) * radius + offsetX;
                positions[i * 3 + 1] = height;
                positions[i * 3 + 2] = Math.sin(angle) * radius + offsetZ;

                // é¢œè‰²æ··åˆ - ä¼˜åŒ–åçš„å±‚æ¬¡æ¸å˜
                let color;
                const deepGold = new THREE.Color(0xFFB84D); // æ·±é‡‘è‰²
                
                // æ ¹æ®é«˜åº¦åˆ†å±‚
                if (t < 0.15) {
                    // åº•éƒ¨ï¼ˆ0-15%ï¼‰ï¼šæ·±é‡‘è‰²åˆ°æš–é‡‘è‰²
                    const bottomT = t / 0.15;
                    color = new THREE.Color().lerpColors(deepGold, warmGold, bottomT);
                } else if (t < 0.4) {
                    // ä¸­ä¸‹éƒ¨ï¼ˆ15-40%ï¼‰ï¼šæš–é‡‘è‰²åˆ°é¦™æ§Ÿé‡‘
                    const midBottomT = (t - 0.15) / 0.25;
                    color = new THREE.Color().lerpColors(warmGold, champagneGold, midBottomT);
                } else if (t < 0.65) {
                    // ä¸­é—´åŒºï¼ˆ40-65%ï¼‰ï¼šé¦™æ§Ÿé‡‘åˆ°ç«ç‘°é‡‘
                    const midT = (t - 0.4) / 0.25;
                    color = new THREE.Color().lerpColors(champagneGold, roseGold, midT);
                } else if (t < 0.85) {
                    // ä¸­ä¸Šéƒ¨ï¼ˆ65-85%ï¼‰ï¼šç«ç‘°é‡‘åˆ°é¦™æ§Ÿé‡‘
                    const midTopT = (t - 0.65) / 0.2;
                    color = new THREE.Color().lerpColors(roseGold, champagneGold, midTopT);
                } else {
                    // é¡¶éƒ¨é«˜å…‰åŒºï¼ˆ85-100%ï¼‰ï¼šé¦™æ§Ÿé‡‘ -> æŸ æª¬ç»¸è‰² -> ç™½è‰²
                    const topT = (t - 0.85) / 0.15;
                    if (topT < 0.5) {
                        // å‰åŠæ®µï¼šé¦™æ§Ÿé‡‘åˆ°æŸ æª¬ç»¸è‰²
                        const firstHalf = topT / 0.5;
                        color = new THREE.Color().lerpColors(champagneGold, lemonChiffon, firstHalf);
                    } else {
                        // ååŠæ®µï¼šæŸ æª¬ç»¸è‰²åˆ°ç™½è‰²
                        const secondHalf = (topT - 0.5) / 0.5;
                        color = new THREE.Color().lerpColors(lemonChiffon, white, secondHalf);
                    }
                }
                
                // éšæœºæ·»åŠ å½©è‰²ç²’å­ï¼ˆç»¿è‰²ã€è“è‰²ã€ç´«è‰²ã€çº¢è‰²ï¼‰- 10%æ¦‚ç‡
                const colorChance = Math.random();
                if (colorChance < 0.025) {
                    // 2.5% ç»¿è‰²ç²’å­
                    const greenColor = new THREE.Color(0x00FF88); // æ˜äº®çš„ç»¿è‰²
                    color.lerp(greenColor, 0.7);
                } else if (colorChance < 0.05) {
                    // 2.5% è“è‰²ç²’å­
                    const blueColor = new THREE.Color(0x00AAFF); // æ˜äº®çš„è“è‰²
                    color.lerp(blueColor, 0.7);
                } else if (colorChance < 0.075) {
                    // 2.5% ç´«è‰²ç²’å­
                    const purpleColor = new THREE.Color(0xAA88FF); // æ˜äº®çš„ç´«è‰²
                    color.lerp(purpleColor, 0.7);
                } else if (colorChance < 0.1) {
                    // 2.5% çº¢è‰²ç²’å­
                    const redColor = new THREE.Color(0xFF4488); // æ˜äº®çš„çº¢è‰²
                    color.lerp(redColor, 0.7);
                }
                
                // æ·»åŠ äº®åº¦å˜åŒ–ï¼Œè®©æ ‘æ›´æœ‰å±‚æ¬¡æ„Ÿ
                const brightnessVariation = 0.85 + Math.random() * 0.3;
                color.multiplyScalar(brightnessVariation);
                
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                // ç²’å­å¤§å°æœ‰ç»†å¾®å·®åˆ«ï¼šåº•éƒ¨ç¨å¤§ï¼Œé¡¶éƒ¨è¾ƒå°ï¼ŒåŠ ä¸Šéšæœºå˜åŒ–
                // åº•éƒ¨ç²’å­ç¨å¤§ï¼Œå¢å¼ºç«‹ä½“æ„Ÿå’Œå¯†åº¦æ„Ÿ
                const baseSize = t < 0.3 ? (0.03 + (1 - t) * 0.015) : (0.022 + (1 - t) * 0.015); // åº•éƒ¨0.03-0.045ï¼Œå…¶ä»–0.022-0.037ï¼ˆå‡å°ï¼‰
                sizes[i] = baseSize * (0.9 + Math.random() * 0.2); // éšæœºå˜åŒ– Â±10%
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.03, // è¿›ä¸€æ­¥å‡å°åŸºç¡€å¤§å°ï¼Œé¿å…çœ‹å‡ºæ–¹å½¢
                vertexColors: true,
                transparent: true,
                opacity: 0.75, // ç¨å¾®æé«˜ä¸é€æ˜åº¦ï¼Œå¢å¼ºè§†è§‰æ•ˆæœ
                sizeAttenuation: true, // å¯ç”¨è·ç¦»è¡°å‡
                blending: THREE.NormalBlending, // ä½¿ç”¨æ­£å¸¸æ··åˆï¼Œé¿å…è¿‡åº¦å‘å…‰
                depthWrite: true, // å†™å…¥æ·±åº¦ç¼“å†²
                depthTest: true // è¿›è¡Œæ·±åº¦æµ‹è¯•
            });

            particleSystem = new THREE.Points(geometry, material);
            particleSystem.renderOrder = 10; // è®¾ç½®è¾ƒé«˜çš„renderOrderï¼Œç¡®ä¿åœ¨å…‰æ™•ä¹‹åæ¸²æŸ“
            scene.add(particleSystem);
        }

        // åˆ›å»ºå½©å¸¦ç¯ç»•æ•ˆæœ - æš‚æ—¶æ³¨é‡Š
        /* function createRibbon() {
            const particleCount = 800;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            const ribbonColors = [
                new THREE.Color(0xFF6B9D), // ç²‰è‰²
                new THREE.Color(0xC44569), // æ·±ç²‰
                new THREE.Color(0xFFD700), // é‡‘è‰²
                new THREE.Color(0xFFA500)  // æ©™è‰²
            ];

            const maxHeight = 12;
            const spiralTurns = 4; // å½©å¸¦èºæ—‹åœˆæ•°
            const treeOffsetY = -5; // ä¸ä¸»æ ‘å¯¹é½

            for (let i = 0; i < particleCount; i++) {
                const t = i / particleCount;
                const height = t * maxHeight + treeOffsetY;
                
                // èºæ—‹è§’åº¦
                const spiralAngle = t * spiralTurns * Math.PI * 2;
                
                // åŠå¾„éšé«˜åº¦å˜åŒ–ï¼ˆä¸‰è§’é”¥å½¢è½®å»“ï¼‰
                const baseRadius = 6;
                const topRadius = 0.2;
                const radius = topRadius + (baseRadius - topRadius) * (1 - t);
                
                // å½©å¸¦åœ¨æ ‘è¡¨é¢ç¨å¾®å¤–å‡¸
                const ribbonRadius = radius * 1.15;
                
                positions[i * 3] = Math.cos(spiralAngle) * ribbonRadius;
                positions[i * 3 + 1] = height;
                positions[i * 3 + 2] = Math.sin(spiralAngle) * ribbonRadius;

                // é¢œè‰²å¾ªç¯å˜åŒ–
                const colorIndex = Math.floor(t * ribbonColors.length) % ribbonColors.length;
                const color = ribbonColors[colorIndex];
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.06, // å‡å°å½©å¸¦ç²’å­å¤§å°
                vertexColors: true,
                transparent: true,
                opacity: 0.7, // é™ä½äº®åº¦
                sizeAttenuation: true
            });

            const ribbon = new THREE.Points(geometry, material);
            ribbon.userData.originalPositions = new Float32Array(positions);
            scene.add(ribbon);
            return ribbon;
        } */

        // åˆ›å»ºé¡¶éƒ¨è£…é¥° - åœ†çƒ
        function createStar() {
            const treeTopHeight = 7; // æ ‘é¡¶é«˜åº¦ï¼ˆmaxHeight=12, offsetY=-5, æ‰€ä»¥é¡¶éƒ¨æ˜¯12-5=7ï¼‰
            const starHeight = treeTopHeight + 0.4; // åœ†çƒåœ¨æ ‘é¡¶ä¸Šæ–¹0.4å•ä½ï¼Œç¨å¾®å‘ä¸Šç§»åŠ¨
            
            // åˆ›å»ºåœ†çƒå‡ ä½•ä½“å’Œæè´¨
            const sphereGeometry = new THREE.SphereGeometry(0.2, 32, 32); // å‡å°åŠå¾„åˆ°0.2ï¼Œè®©åœ†çƒæ›´å°æ›´æ¸…æ¥š
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF, // çº¯ç™½è‰²
                transparent: true,
                opacity: 1.0, // å®Œå…¨ä¸é€æ˜ï¼Œç¡®ä¿æ¸…æ™°
                blending: THREE.NormalBlending, // ä½¿ç”¨NormalBlendingç¡®ä¿æ¸…æ™°
                depthWrite: false, // ä¸å†™å…¥æ·±åº¦ç¼“å†²ï¼Œé€šè¿‡renderOrderæ§åˆ¶
                depthTest: false // ä¸è¿›è¡Œæ·±åº¦æµ‹è¯•ï¼Œé€šè¿‡renderOrderç¡®ä¿åœ¨æœ€å‰é¢
            });
            
            // åˆ›å»ºåœ†çƒMesh
            const starSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            starSphere.position.set(0, 0, 0); // æ¢å¤Z=0
            starSphere.renderOrder = 20; // æœ€é«˜çš„renderOrderï¼Œç¡®ä¿åœ¨æœ€å‰é¢
            
            // åˆ›å»ºæŸ”å’Œçš„çƒå½¢å…‰æ™•ç»„ï¼ˆå‚è€ƒå›¾2çš„æ•ˆæœï¼ŒæŸ”å’Œçš„å…‰æ™•ä½†ä¸é®æŒ¡äº”è§’æ˜Ÿï¼‰
            // ä½¿ç”¨Spriteåˆ›å»ºå…‰æ™•ï¼Œç¡®ä¿å’Œäº”è§’æ˜Ÿåœ¨åŒä¸€æ¸²æŸ“å±‚ï¼Œä¸ä¼šé®æŒ¡
            const haloGroup = new THREE.Group();
            
            // åˆ›å»ºå…‰æ™•çº¹ç†ï¼ˆåœ†å½¢æ¸å˜ï¼‰- ä½¿ç”¨å°Šè´µçš„é»„è‰²ï¼Œæ›´æŸ”å’Œæ›´å¤§
            const haloCanvas = document.createElement('canvas');
            haloCanvas.width = 512; // å¢å¤§ç”»å¸ƒï¼Œè·å¾—æ›´å¹³æ»‘çš„æ¸å˜
            haloCanvas.height = 512;
            const haloCtx = haloCanvas.getContext('2d');
            // ä½¿ç”¨å°Šè´µçš„é»„è‰²æ¸å˜ï¼ˆé‡‘è‰²åˆ°æ·¡é»„è‰²ï¼‰
            const haloGradient = haloCtx.createRadialGradient(256, 256, 0, 256, 256, 256);
            haloGradient.addColorStop(0, 'rgba(255, 215, 0, 0.25)'); // ä¸­å¿ƒé‡‘è‰²ï¼Œæ›´æŸ”å’Œ
            haloGradient.addColorStop(0.2, 'rgba(255, 223, 100, 0.18)'); // æ·¡é‡‘è‰²
            haloGradient.addColorStop(0.4, 'rgba(255, 235, 150, 0.12)'); // æ›´æ·¡çš„é‡‘è‰²
            haloGradient.addColorStop(0.6, 'rgba(255, 245, 200, 0.06)'); // å¾ˆæ·¡çš„é»„è‰²
            haloGradient.addColorStop(1, 'rgba(255, 250, 220, 0)'); // å®Œå…¨é€æ˜
            haloCtx.fillStyle = haloGradient;
            haloCtx.fillRect(0, 0, 512, 512);
            
            const haloTexture = new THREE.CanvasTexture(haloCanvas);
            haloTexture.needsUpdate = true;
            
            // ç®€åŒ–å…‰æ™• - åªä¿ç•™ä¸€å±‚ï¼Œæ›´ç®€å•è‡ªç„¶
            const haloMaterial = new THREE.SpriteMaterial({
                map: haloTexture,
                color: 0xFFD700, // é‡‘è‰²
                transparent: true,
                opacity: 0.15, // é€‚ä¸­çš„ä¸é€æ˜åº¦
                blending: THREE.AdditiveBlending,
                depthWrite: false, // ä¸å†™å…¥æ·±åº¦ç¼“å†²ï¼Œé¿å…é®æŒ¡ç²’å­
                depthTest: false // ä¸è¿›è¡Œæ·±åº¦æµ‹è¯•ï¼Œé€šè¿‡renderOrderæ§åˆ¶æ¸²æŸ“é¡ºåº
            });
            const halo = new THREE.Sprite(haloMaterial);
            halo.scale.set(1.5, 1.5, 1); // é€‚ä¸­çš„å…‰æ™•å¤§å°
            halo.position.set(0, 0, 0); // æ¢å¤Z=0
            halo.renderOrder = 5; // åœ¨ç²’å­ç³»ç»Ÿä¹‹å‰æ¸²æŸ“
            haloGroup.add(halo);
            
            const starGroup = new THREE.Group();
            // å…ˆæ·»åŠ å…‰æ™•ï¼ˆrenderOrderè¾ƒä½ï¼‰ï¼Œå†æ·»åŠ åœ†çƒï¼ˆrenderOrderæœ€é«˜ï¼‰
            starGroup.add(haloGroup);
            starGroup.add(starSphere);
            
            // ä¿å­˜åŸå§‹ä½ç½® - groupçš„ä½ç½®è®¾ç½®ä¸ºstarHeight
            starGroup.userData.originalPosition = new THREE.Vector3(0, starHeight, 0);
            starGroup.position.copy(starGroup.userData.originalPosition);
            
            // ç¡®ä¿åœ†çƒå¯è§
            starGroup.visible = true;
            starSphere.visible = true;
            haloGroup.visible = true;
            
            scene.add(starGroup);
            
            return starGroup;
        }

        // åˆ›å»ºè£…é¥°å°çƒï¼ˆé‡‘è‰²ã€çº¢è‰²ï¼‰
        function createOrnaments() {
            const particleCount = 200; // è£…é¥°å°çƒæ•°é‡
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            const goldColor = new THREE.Color(0xFFD700); // é‡‘è‰²
            const gemRedColor = new THREE.Color(0xE0115F); // å®çŸ³çº¢ - çƒ­æƒ…/çˆ±
            const deepRedColor = new THREE.Color(0xCC0000); // æ·±çº¢è‰²ï¼ˆä¿ç•™éƒ¨åˆ†ï¼‰

            const maxHeight = 12;
            const baseRadius = 6; // ä¸ä¸»æ ‘å¯¹é½
            const topRadius = 0.05;
            const treeOffsetY = -5; // ä¸ä¸»æ ‘å¯¹é½

            for (let i = 0; i < particleCount; i++) {
                // åœ¨æ ‘è¡¨é¢éšæœºåˆ†å¸ƒï¼Œä½†é¿å…åº•éƒ¨å’Œé¡¶éƒ¨
                const t = 0.15 + Math.random() * 0.7; // é›†ä¸­åœ¨ä¸­é—´åŒºåŸŸ
                const height = t * maxHeight + treeOffsetY;
                const layerMaxRadius = topRadius + (baseRadius - topRadius) * (1 - t);
                
                // åœ¨æ ‘è¡¨é¢åˆ†å¸ƒï¼ˆç¨å¾®å¤–å‡¸ï¼‰ï¼Œä½†ä¸è¦å¤ªå¤–å‡¸
                const angle = Math.random() * Math.PI * 2;
                const radius = layerMaxRadius * (0.92 + Math.random() * 0.15); // åœ¨æ ‘è¡¨é¢é™„è¿‘
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;

                // éšæœºé€‰æ‹©é‡‘è‰²æˆ–å®çŸ³çº¢ - å‡å°‘çº¢è‰²æ¯”ä¾‹ï¼ˆ70%é‡‘è‰²ï¼Œ30%çº¢è‰²ï¼‰
                const isGold = Math.random() > 0.3; // ä»0.5æ”¹ä¸º0.3ï¼Œå‡å°‘çº¢è‰²
                const color = isGold ? goldColor : gemRedColor;
                
                // æ·»åŠ äº®åº¦å˜åŒ–ï¼Œå®çŸ³çº¢å¢åŠ å‘å…‰å¼ºåº¦
                let brightness = 0.8 + Math.random() * 0.2;
                if (!isGold) {
                    // å®çŸ³çº¢å¢åŠ å‘å…‰å¼ºåº¦ï¼Œåƒå°ç¯æ³¡ä¸€æ ·é—ªçƒ
                    brightness = 1.0 + Math.random() * 0.3; // 1.0-1.3ï¼Œæ›´äº®
                }
                colors[i * 3] = color.r * brightness;
                colors[i * 3 + 1] = color.g * brightness;
                colors[i * 3 + 2] = color.b * brightness;

                // å°çƒå¤§å° - å¾ˆå°
                sizes[i] = 0.02 + Math.random() * 0.02; // 0.02 åˆ° 0.04
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.05, // ç¨å¾®å¢å¤§ï¼Œè®©è£…é¥°æ›´æ˜æ˜¾
                vertexColors: true,
                transparent: true,
                opacity: 0.9, // æé«˜ä¸é€æ˜åº¦ï¼Œå¢å¼ºå‘å…‰
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending // å¢å¼ºå‘å…‰æ•ˆæœï¼Œå®çŸ³çº¢åƒå°ç¯æ³¡ä¸€æ ·é—ªçƒ
            });

            const ornaments = new THREE.Points(geometry, material);
            ornaments.userData.originalPositions = new Float32Array(positions);
            scene.add(ornaments);
            return ornaments;
        }

        // åˆ›å»ºé›ªèŠ±ç³»ç»Ÿ - å…­è¾¹å½¢é›ªèŠ±ï¼ˆä½¿ç”¨Spriteï¼‰
        function createSnowSystem() {
            const particleCount = 1000; // å¤§å¹…å¢åŠ é›ªèŠ±æ•°é‡
            const snowGroup = new THREE.Group();
            const velocities = [];

            // åˆ›å»ºæ›´ç²¾ç¾çš„å…­è¾¹å½¢é›ªèŠ±çº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 256; // å¢å¤§åˆ†è¾¨ç‡ï¼Œè®©é›ªèŠ±æ›´æ¸…æ™°
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // ç»˜åˆ¶å…­è¾¹å½¢é›ªèŠ± - æ›´ç²¾ç»†çš„è®¾è®¡
            ctx.clearRect(0, 0, 256, 256);
            ctx.translate(128, 128);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // ç»˜åˆ¶ä¸­å¿ƒå…­è¾¹å½¢
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const x = Math.cos(angle) * 50;
                const y = Math.sin(angle) * 50;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
            
            // æ·»åŠ ä¸­å¿ƒç‚¹
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // æ·»åŠ 6ä¸ªä¸»åˆ†æ”¯
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const startX = Math.cos(angle) * 50;
                const startY = Math.sin(angle) * 50;
                const endX = Math.cos(angle) * 80;
                const endY = Math.sin(angle) * 80;
                
                // ä¸»åˆ†æ”¯
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // æ¯ä¸ªä¸»åˆ†æ”¯ä¸Šçš„å°åˆ†æ”¯ï¼ˆå·¦å³å„ä¸€ä¸ªï¼‰
                const branchAngle1 = angle + Math.PI / 6;
                const branchAngle2 = angle - Math.PI / 6;
                const branchLength = 25;
                
                ctx.beginPath();
                ctx.moveTo(startX + (endX - startX) * 0.6, startY + (endY - startY) * 0.6);
                ctx.lineTo(
                    startX + (endX - startX) * 0.6 + Math.cos(branchAngle1) * branchLength,
                    startY + (endY - startY) * 0.6 + Math.sin(branchAngle1) * branchLength
                );
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(startX + (endX - startX) * 0.6, startY + (endY - startY) * 0.6);
                ctx.lineTo(
                    startX + (endX - startX) * 0.6 + Math.cos(branchAngle2) * branchLength,
                    startY + (endY - startY) * 0.6 + Math.sin(branchAngle2) * branchLength
                );
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.75, // ç¨å¾®æé«˜ä¸é€æ˜åº¦
                blending: THREE.AdditiveBlending
            });

            for (let i = 0; i < particleCount; i++) {
                const sprite = new THREE.Sprite(spriteMaterial);
                // æ‰©å¤§åˆ†å¸ƒèŒƒå›´
                sprite.position.set(
                    (Math.random() - 0.5) * 60,
                    Math.random() * 30 + 5,
                    (Math.random() - 0.5) * 60
                );
                // é›ªèŠ±å¤§å°æœ‰å˜åŒ–
                const size = 0.12 + Math.random() * 0.08; // 0.12 åˆ° 0.20
                sprite.scale.set(size, size, 1);
                sprite.rotation.z = Math.random() * Math.PI * 2;

                velocities.push({
                    sprite: sprite,
                    x: (Math.random() - 0.5) * 0.02,
                    y: -Math.random() * 0.05 - 0.02,
                    z: (Math.random() - 0.5) * 0.02,
                    rotation: (Math.random() - 0.5) * 0.025
                });

                snowGroup.add(sprite);
            }

            scene.add(snowGroup);
            snowSystem = { group: snowGroup, velocities, material: spriteMaterial };
        }

        // æ›´æ–°é›ªèŠ±
        function updateSnow() {
            if (!snowSystem) return;
            const velocities = snowSystem.velocities;

            for (let i = 0; i < velocities.length; i++) {
                const sprite = velocities[i].sprite;
                sprite.position.x += velocities[i].x;
                sprite.position.y += velocities[i].y;
                sprite.position.z += velocities[i].z;
                sprite.rotation.z += velocities[i].rotation;

                if (sprite.position.y < -5) {
                    sprite.position.y = 15;
                    sprite.position.x = (Math.random() - 0.5) * 50;
                    sprite.position.z = (Math.random() - 0.5) * 50;
                }
            }
        }

        // ç²’å­æ—‹è½¬åŠ¨ç”»ï¼ˆç§»é™¤ç¼©æ”¾æ•ˆæœï¼‰
        let breathingPhase = 0; // ä¿ç•™ç”¨äºæ˜Ÿæ˜Ÿé—ªçƒ
        let rotationAngle = 0;
        function animateParticles() {
            breathingPhase += 0.015;
            rotationAngle += 0.001; // æ›´æ…¢çš„æ—‹è½¬

            if (particleSystem) {
                if (currentGesture === 'fist') {
                    // åœ£è¯æ ‘ç¼“æ…¢æ—‹è½¬
                    particleSystem.rotation.y = rotationAngle;
                    
                    const positions = particleSystem.geometry.attributes.position.array;
                    const originalPositions = particleSystem.userData.originalPositions || positions.slice();

                    if (!particleSystem.userData.originalPositions) {
                        particleSystem.userData.originalPositions = new Float32Array(originalPositions);
                    }

                    // èšåˆæ—¶å¹³æ»‘å›åˆ°åŸå§‹ä½ç½® - ç§»é™¤ç¼©æ”¾æ•ˆæœï¼Œåªä¿ç•™æ—‹è½¬
                    // ä¼˜åŒ–ï¼šåªåœ¨ä½ç½®å˜åŒ–è¾ƒå¤§æ—¶æ‰æ›´æ–°geometry
                    let needsUpdate = false;
                    const lerpSpeed = 0.15; // å¢åŠ æ’å€¼é€Ÿåº¦ï¼Œå‡å°‘å¡é¡¿
                    const threshold = 0.01; // ä½ç½®å˜åŒ–é˜ˆå€¼
                    for (let i = 0; i < originalPositions.length; i += 3) {
                        const targetX = particleSystem.userData.originalPositions[i];
                        const targetY = particleSystem.userData.originalPositions[i + 1];
                        const targetZ = particleSystem.userData.originalPositions[i + 2];
                        const dx = targetX - positions[i];
                        const dy = targetY - positions[i + 1];
                        const dz = targetZ - positions[i + 2];
                        if (Math.abs(dx) > threshold || Math.abs(dy) > threshold || Math.abs(dz) > threshold) {
                            needsUpdate = true;
                            positions[i] += dx * lerpSpeed;
                            positions[i + 1] += dy * lerpSpeed;
                            positions[i + 2] += dz * lerpSpeed;
                        }
                    }
                    if (needsUpdate) {
                        particleSystem.geometry.attributes.position.needsUpdate = true;
                    }
                } else if (currentGesture === 'open') {
                    // æ•£å¼€æ—¶ä¹Ÿæ—‹è½¬
                    particleSystem.rotation.y = rotationAngle;
                    
                    // å¹³æ»‘æ•£å¼€ä¸»æ ‘ç²’å­ - ä¼˜åŒ–æ€§èƒ½
                    if (particleSystem.userData.scatterTargets) {
                        const positions = particleSystem.geometry.attributes.position.array;
                        const targets = particleSystem.userData.scatterTargets;
                        const lerpSpeed = 0.08; // å¢åŠ æ’å€¼é€Ÿåº¦
                        const threshold = 0.01; // ä½ç½®å˜åŒ–é˜ˆå€¼
                        let needsUpdate = false;
                        for (let i = 0; i < positions.length; i++) {
                            const diff = targets[i] - positions[i];
                            if (Math.abs(diff) > threshold) {
                                needsUpdate = true;
                                positions[i] += diff * lerpSpeed;
                            }
                        }
                        if (needsUpdate) {
                            particleSystem.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                }
            }

            // å½©å¸¦åŠ¨ç”» - å·²æ³¨é‡Š
            /* if (ribbonSystem) {
                if (currentGesture === 'fist') {
                    ribbonSystem.rotation.y = rotationAngle * 1.2;
                } else if (currentGesture === 'open') {
                    if (ribbonSystem.userData.scatterTargets && ribbonSystem.geometry) {
                        const positions = ribbonSystem.geometry.attributes.position.array;
                        const targets = ribbonSystem.userData.scatterTargets;
                        for (let i = 0; i < positions.length; i++) {
                            positions[i] += (targets[i] - positions[i]) * 0.05;
                        }
                        ribbonSystem.geometry.attributes.position.needsUpdate = true;
                    }
                } else {
                    if (ribbonSystem.userData.originalPositions && ribbonSystem.geometry) {
                        const positions = ribbonSystem.geometry.attributes.position.array;
                        const originalPositions = ribbonSystem.userData.originalPositions;
                        for (let i = 0; i < positions.length; i++) {
                            positions[i] += (originalPositions[i] - positions[i]) * 0.1;
                        }
                        ribbonSystem.geometry.attributes.position.needsUpdate = true;
                    }
                }
            } */

            // é¡¶éƒ¨æ˜Ÿæ˜ŸåŠ¨ç”» - å›ºå®šåœ¨æ ‘é¡¶éƒ¨ï¼Œä¸æ—‹è½¬
            if (starSystem && particleSystem) {
                // æ˜Ÿæ˜Ÿä¸æ—‹è½¬ï¼Œä¿æŒå›ºå®šæ–¹å‘
                starSystem.rotation.y = 0;
                // ç¡®ä¿æ˜Ÿæ˜Ÿåœ¨åŸå§‹ä½ç½®
                if (starSystem.userData.originalPosition) {
                    starSystem.position.copy(starSystem.userData.originalPosition);
                }
            }

            // è£…é¥°å°çƒåŠ¨ç”»
            if (ornamentSystem) {
                if (currentGesture === 'fist') {
                    // è£…é¥°å°çƒéšæ ‘æ—‹è½¬
                    ornamentSystem.rotation.y = rotationAngle;
                } else if (currentGesture === 'open') {
                    // æ•£å¼€æ—¶ä¹Ÿæ—‹è½¬
                    ornamentSystem.rotation.y = rotationAngle;
                    // æ•£å¼€è£…é¥°å°çƒ
                    if (ornamentSystem.userData.scatterTargets && ornamentSystem.geometry) {
                        const positions = ornamentSystem.geometry.attributes.position.array;
                        const targets = ornamentSystem.userData.scatterTargets;
                        for (let i = 0; i < positions.length; i++) {
                            positions[i] += (targets[i] - positions[i]) * 0.05;
                        }
                        ornamentSystem.geometry.attributes.position.needsUpdate = true;
                    }
                } else {
                    // èšåˆæ—¶å›åˆ°åŸå§‹ä½ç½®
                    if (ornamentSystem.userData.originalPositions && ornamentSystem.geometry) {
                        const positions = ornamentSystem.geometry.attributes.position.array;
                        const originalPositions = ornamentSystem.userData.originalPositions;
                        for (let i = 0; i < positions.length; i++) {
                            positions[i] += (originalPositions[i] - positions[i]) * 0.1;
                        }
                        ornamentSystem.geometry.attributes.position.needsUpdate = true;
                    }
                }
            }
        }

        // æ‰‹åŠ¿å¤„ç†
        function handleGesture(gesture) {
            currentGesture = gesture;

            // æ›´æ–°UI
            document.querySelectorAll('.gesture-item').forEach(item => {
                item.classList.remove('active');
            });
            if (gesture === 'fist') {
                document.getElementById('gestureFist').classList.add('active');
            } else if (gesture === 'open') {
                document.getElementById('gestureOpen').classList.add('active');
            } else if (gesture === 'pinch') {
                document.getElementById('gesturePinch').classList.add('active');
            }

            // å¤„ç†ç²’å­çŠ¶æ€
            if (gesture === 'fist') {
                // èšåˆåœ£è¯æ ‘ - æ¸…é™¤æ•£å¼€ç›®æ ‡ï¼Œè®©ç²’å­å¹³æ»‘å›åˆ°åŸå§‹ä½ç½®
                if (particleSystem) {
                    particleSystem.userData.scatterTargets = null;
                }
                // å½©å¸¦å·²æ³¨é‡Š
                // if (ribbonSystem) {
                //     ribbonSystem.userData.scatterTargets = null;
                // }
                if (starSystem) {
                    starSystem.userData.scatterTarget = null;
                }
                if (ornamentSystem) {
                    ornamentSystem.userData.scatterTargets = null;
                }
                // å¹³æ»‘å›åˆ°åŸå§‹ä½ç½®ï¼ˆåœ¨animateParticlesä¸­å¤„ç†ï¼‰
                // ç…§ç‰‡ç¼©å°ä¸ºæŒ‚é¥°ï¼Œåˆ†å¸ƒåœ¨æ ‘ä¸Š - åªåœ¨çŠ¶æ€æ”¹å˜æ—¶è®¡ç®—ä¸€æ¬¡
                photos.forEach(photo => {
                    if (photo.mesh && photo !== focusedPhoto && !photo.isOnTree) {
                        photo.targetScale = 0.4; // å‡å°ç¼©ç•¥å›¾å¤§å°
                        // æ¸…é™¤æ•£å¼€ä½ç½®æ ‡è®°
                        photo.scatterPosition = null;
                        // åœ¨æ ‘ä¸Šé‡æ–°åˆ†å¸ƒ - åªè®¡ç®—ä¸€æ¬¡
                        const maxHeight = 12;
                        const baseRadius = 6;
                        const topRadius = 0.05;
                        const treeOffsetY = -5;
                        const t = 0.2 + Math.random() * 0.6;
                        const height = t * maxHeight + treeOffsetY;
                        const layerMaxRadius = topRadius + (baseRadius - topRadius) * (1 - t);
                        const angle = Math.random() * Math.PI * 2;
                        const radius = layerMaxRadius * (0.85 + Math.random() * 0.15);
                        photo.targetPosition = new THREE.Vector3(
                            Math.cos(angle) * radius,
                            height,
                            Math.sin(angle) * radius
                        );
                        photo.isFocused = false;
                        photo.isOnTree = true; // æ ‡è®°å·²åœ¨æ ‘ä¸Š
                    }
                });
                if (focusedPhoto) {
                    focusedPhoto.isFocused = false;
                    focusedPhoto.targetScale = 0.4; // å‡å°ç¼©ç•¥å›¾å¤§å°
                    focusedPhoto.isOnTree = false; // é‡ç½®æ ‡è®°
                    focusedPhoto = null;
                }
            } else if (gesture === 'open') {
                // æ•£å¼€æ‚¬æµ® - å¹³æ»‘æ•£å¼€æ‰€æœ‰ç²’å­
                if (particleSystem && particleSystem.userData.originalPositions) {
                    // åˆå§‹åŒ–æ•£å¼€ç›®æ ‡ä½ç½®ï¼ˆåªåˆå§‹åŒ–ä¸€æ¬¡ï¼‰
                    if (!particleSystem.userData.scatterTargets) {
                        const positions = particleSystem.geometry.attributes.position.array;
                        particleSystem.userData.scatterTargets = new Float32Array(positions.length);
                        for (let i = 0; i < positions.length; i += 3) {
                            const scatterRadius = Math.random() * 15 + 5; // æ•£å¼€åŠå¾„
                            const scatterAngle = Math.random() * Math.PI * 2;
                            const scatterHeight = (Math.random() - 0.5) * 10;
                            particleSystem.userData.scatterTargets[i] = Math.cos(scatterAngle) * scatterRadius;
                            particleSystem.userData.scatterTargets[i + 1] = positions[i + 1] + scatterHeight;
                            particleSystem.userData.scatterTargets[i + 2] = Math.sin(scatterAngle) * scatterRadius;
                        }
                    }
                }
                // å½©å¸¦å·²æ³¨é‡Š
                /* if (ribbonSystem && ribbonSystem.geometry) {
                    if (!ribbonSystem.userData.scatterTargets) {
                        const positions = ribbonSystem.geometry.attributes.position.array;
                        ribbonSystem.userData.scatterTargets = new Float32Array(positions.length);
                        for (let i = 0; i < positions.length; i += 3) {
                            const scatterRadius = Math.random() * 15 + 5;
                            const scatterAngle = Math.random() * Math.PI * 2;
                            const scatterHeight = (Math.random() - 0.5) * 10;
                            ribbonSystem.userData.scatterTargets[i] = Math.cos(scatterAngle) * scatterRadius;
                            ribbonSystem.userData.scatterTargets[i + 1] = positions[i + 1] + scatterHeight;
                            ribbonSystem.userData.scatterTargets[i + 2] = Math.sin(scatterAngle) * scatterRadius;
                        }
                    }
                } */
                // æ˜Ÿæ˜Ÿä¹Ÿæ•£å¼€ï¼ˆæ˜Ÿæ˜Ÿç°åœ¨æ˜¯Meshï¼Œç›´æ¥ç§»åŠ¨ä½ç½®ï¼‰
                if (starSystem) {
                    if (!starSystem.userData.scatterTarget) {
                        const scatterRadius = Math.random() * 10 + 3;
                        const scatterAngle = Math.random() * Math.PI * 2;
                        const scatterHeight = (Math.random() - 0.5) * 8;
                        starSystem.userData.scatterTarget = new THREE.Vector3(
                            Math.cos(scatterAngle) * scatterRadius,
                            starSystem.position.y + scatterHeight,
                            Math.sin(scatterAngle) * scatterRadius
                        );
                    }
                }
                // è£…é¥°å°çƒä¹Ÿæ•£å¼€
                if (ornamentSystem && ornamentSystem.geometry) {
                    if (!ornamentSystem.userData.scatterTargets) {
                        const positions = ornamentSystem.geometry.attributes.position.array;
                        ornamentSystem.userData.scatterTargets = new Float32Array(positions.length);
                        for (let i = 0; i < positions.length; i += 3) {
                            const scatterRadius = Math.random() * 12 + 3;
                            const scatterAngle = Math.random() * Math.PI * 2;
                            const scatterHeight = (Math.random() - 0.5) * 8;
                            ornamentSystem.userData.scatterTargets[i] = Math.cos(scatterAngle) * scatterRadius;
                            ornamentSystem.userData.scatterTargets[i + 1] = positions[i + 1] + scatterHeight;
                            ornamentSystem.userData.scatterTargets[i + 2] = Math.sin(scatterAngle) * scatterRadius;
                        }
                    }
                }
                // ç…§ç‰‡æ•£å¼€ - åªåœ¨çŠ¶æ€æ”¹å˜æ—¶è®¡ç®—ä¸€æ¬¡
                photos.forEach(photo => {
                    if (photo.mesh && photo !== focusedPhoto && photo.isOnTree) {
                        photo.targetScale = 0.5;
                        // åªåœ¨ç¬¬ä¸€æ¬¡æ•£å¼€æ—¶è®¡ç®—ä½ç½®ï¼Œé¿å…æ¯å¸§éƒ½å˜åŒ–
                        if (!photo.scatterPosition) {
                            photo.targetPosition = new THREE.Vector3(
                                (Math.random() - 0.5) * 20,
                                Math.random() * 15,
                                (Math.random() - 0.5) * 20
                            );
                            photo.scatterPosition = photo.targetPosition.clone();
                        } else {
                            photo.targetPosition = photo.scatterPosition.clone();
                        }
                        photo.isFocused = false;
                        photo.isOnTree = false; // é‡ç½®æ ‡è®°
                    }
                });
                if (focusedPhoto) {
                    focusedPhoto.isFocused = false;
                    focusedPhoto.targetScale = 0.5;
                    focusedPhoto.isOnTree = false; // é‡ç½®æ ‡è®°
                    focusedPhoto.scatterPosition = null;
                    focusedPhoto = null;
                }
            }
        }

        // å¤„ç†æåˆæ‰‹åŠ¿
        function handlePinch(landmarks) {
            if (photos.length === 0) return;

            // è®¡ç®—å±å¹•ä¸­å¿ƒæœ€è¿‘çš„ç…§ç‰‡
            let closestPhoto = null;
            let minDistance = Infinity;

            photos.forEach(photo => {
                if (!photo.mesh) return;
                const worldPos = new THREE.Vector3();
                photo.mesh.getWorldPosition(worldPos);
                
                // å°†3Dä½ç½®æŠ•å½±åˆ°å±å¹•ç©ºé—´
                const vector = worldPos.clone().project(camera);
                const screenPos = new THREE.Vector2(vector.x, vector.y);
                const screenCenter = new THREE.Vector2(0, 0);
                const distance = screenPos.distanceTo(screenCenter);

                if (distance < minDistance) {
                    minDistance = distance;
                    closestPhoto = photo;
                }
            });

            if (closestPhoto && closestPhoto !== focusedPhoto) {
                // å–æ¶ˆä¹‹å‰çš„èšç„¦
                if (focusedPhoto) {
                    focusedPhoto.isFocused = false;
                    focusedPhoto.targetScale = 0.6;
                }
                
                focusedPhoto = closestPhoto;
                
                // è®¡ç®—åˆé€‚çš„ç¼©æ”¾æ¯”ä¾‹ï¼ˆå±å¹•é«˜åº¦çš„60%ï¼‰ï¼Œä¿æŒå®½é«˜æ¯”ï¼Œç¨å¾®ç¼©å°ä»¥é€‚åº”å±å¹•
                const fov = camera.fov * (Math.PI / 180);
                const focusDistance = 8; // è·ç¦»æ‘„åƒæœºçš„è·ç¦»
                const screenHeight = 2 * Math.tan(fov / 2) * focusDistance;
                const baseSize = screenHeight * 0.6; // ä»0.7å‡å°åˆ°0.6
                // æ ¹æ®ç…§ç‰‡å®½é«˜æ¯”è°ƒæ•´ç¼©æ”¾
                const aspectRatio = focusedPhoto.aspectRatio || 1;
                // ç¡®ä¿ç…§ç‰‡ä¸ä¼šè¶…å‡ºå±å¹• - å¦‚æœç…§ç‰‡å¾ˆå®½æˆ–å¾ˆé«˜ï¼Œéœ€è¦ç¼©å°
                const maxWidth = screenHeight * 0.9; // æœ€å¤§å®½åº¦ä¸ºå±å¹•é«˜åº¦çš„90%
                const maxHeight = screenHeight * 0.9; // æœ€å¤§é«˜åº¦ä¹Ÿä¸ºå±å¹•é«˜åº¦çš„90%
                const photoWidth = baseSize * aspectRatio;
                const photoHeight = baseSize;
                // æ ¹æ®å®½é«˜æ¯”é€‰æ‹©çº¦æŸ
                let finalScale = baseSize;
                if (aspectRatio > 1) {
                    // æ¨ªå›¾ï¼šä»¥å®½åº¦ä¸ºçº¦æŸ
                    finalScale = photoWidth > maxWidth ? maxWidth / aspectRatio : baseSize;
                } else {
                    // ç«–å›¾ï¼šä»¥é«˜åº¦ä¸ºçº¦æŸ
                    finalScale = photoHeight > maxHeight ? maxHeight : baseSize;
                }
                focusedPhoto.targetScale = finalScale;
                // ä¿å­˜å®½é«˜æ¯”ï¼Œåœ¨updatePhotosä¸­ä½¿ç”¨
                focusedPhoto.targetAspectRatio = aspectRatio;
                
                // å°†ç…§ç‰‡ç§»åŠ¨åˆ°æ‘„åƒæœºå‰æ–¹ï¼Œç¡®ä¿åœ¨å±å¹•ä¸­å¿ƒ
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                focusedPhoto.targetPosition = camera.position.clone().add(
                    cameraDirection.multiplyScalar(focusDistance)
                );
                focusedPhoto.isFocused = true;
            }
        }

        // æ›´æ–°ç…§ç‰‡ä½ç½®å’Œç¼©æ”¾
        function updatePhotos() {
            photos.forEach((photo, index) => {
                if (!photo.mesh) return;

                if (photo.targetPosition) {
                    photo.mesh.position.lerp(photo.targetPosition, 0.15);
                }
                if (photo.targetScale !== undefined) {
                    // ä¿æŒç…§ç‰‡å®½é«˜æ¯” - ç®€åŒ–å¤„ç†ï¼Œç›´æ¥åº”ç”¨scale
                    const scale = photo.targetScale;
                    // geometryå·²ç»æ ¹æ®aspectRatioè®¾ç½®äº†æ­£ç¡®çš„å®½é«˜æ¯”ï¼Œç›´æ¥ç»Ÿä¸€åº”ç”¨scaleå³å¯
                    photo.mesh.scale.set(scale, scale, 1);
                }

                if (photo.isFocused) {
                    // èšç„¦æ—¶è°ƒæ•´æè´¨äº®åº¦ï¼Œé¿å…è¿‡äº®
                    if (photo.mesh.material) {
                        // é™ä½èšç„¦ç…§ç‰‡çš„äº®åº¦ï¼Œé¿å…è¿‡äº®
                        photo.mesh.material.color.setHex(0xcccccc); // ä¿æŒè¾ƒä½äº®åº¦
                    }
                    // ç¡®ä¿ç…§ç‰‡æ­£å¯¹æ‘„åƒæœºï¼Œæ— é€è§†å˜å½¢
                    // è®¡ç®—ä»ç…§ç‰‡åˆ°æ‘„åƒæœºçš„æ–¹å‘
                    const direction = new THREE.Vector3();
                    direction.subVectors(camera.position, photo.mesh.position).normalize();
                    // è®¾ç½®ç…§ç‰‡æœå‘æ‘„åƒæœº
                    photo.mesh.lookAt(photo.mesh.position.clone().add(direction));
                    // ç¡®ä¿ç…§ç‰‡ä¸å±å¹•å¹³è¡Œï¼ˆä½¿ç”¨æ‘„åƒæœºçš„æ—‹è½¬ï¼‰
                    const up = new THREE.Vector3(0, 1, 0);
                    photo.mesh.up.copy(up);
                    photo.mesh.lookAt(camera.position);
                } else {
                    // éèšç„¦æ—¶æ¢å¤æ­£å¸¸äº®åº¦
                    if (photo.mesh.material) {
                        photo.mesh.material.color.setHex(0xcccccc); // ä¿æŒä¸€è‡´çš„äº®åº¦
                    }
                    // éèšç„¦çŠ¶æ€ä¸‹çš„æ—‹è½¬åŠ¨ç”» - å§‹ç»ˆè·Ÿéšæ ‘ç¼“æ…¢æ—‹è½¬
                    photo.mesh.rotation.y = rotationAngle;
                }
            });
        }

        // åˆå§‹åŒ–MediaPipe
        async function initMediaPipe() {
            try {
                // ä½¿ç”¨åŠ¨æ€å¯¼å…¥MediaPipe
                const visionModule = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3');
                const { HandLandmarker, FilesetResolver } = visionModule;
                
                const vision = await FilesetResolver.forVisionTasks(
                    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'
                );

                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                // å¯åŠ¨æ‘„åƒå¤´
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 640, height: 480, facingMode: 'user' }
                    });
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', () => {
                        detectHands();
                    });
                } catch (camError) {
                    console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', camError);
                    alert('éœ€è¦æ‘„åƒå¤´æƒé™æ‰èƒ½ä½¿ç”¨æ‰‹åŠ¿è¯†åˆ«åŠŸèƒ½');
                }
            } catch (error) {
                console.error('MediaPipeåˆå§‹åŒ–å¤±è´¥:', error);
                // å¦‚æœMediaPipeåŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºæç¤ºä½†ä¸é˜»æ­¢åº”ç”¨è¿è¡Œ
                const sidebar = document.querySelector('.gesture-sidebar');
                if (sidebar) {
                    sidebar.innerHTML = '<div style="color: rgba(255,218,224,0.5);">æ‰‹åŠ¿è¯†åˆ«åŠŸèƒ½ä¸å¯ç”¨<br/>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥</div>';
                }
            }
        }

        // æ£€æµ‹æ‰‹åŠ¿
        function detectHands() {
            if (!handLandmarker || video.readyState !== video.HAVE_ENOUGH_DATA) {
                requestAnimationFrame(detectHands);
                return;
            }

            const results = handLandmarker.detectForVideo(video, performance.now());

            if (results.landmarks && results.landmarks.length > 0) {
                const landmarks = results.landmarks[0];
                
                // æ£€æµ‹æ‰‹åŠ¿ç±»å‹
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                const thumbMCP = landmarks[2];
                const indexMCP = landmarks[5];
                const middleMCP = landmarks[9];
                const ringMCP = landmarks[13];
                const pinkyMCP = landmarks[17];

                // è®¡ç®—è·ç¦»
                const thumbIndexDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // æ£€æµ‹æ˜¯å¦æ¡æ‹³
                const fingersDown = [
                    indexTip.y > indexMCP.y,
                    middleTip.y > middleMCP.y,
                    ringTip.y > ringMCP.y,
                    pinkyTip.y > pinkyMCP.y
                ].filter(Boolean).length;

                if (fingersDown >= 3 && thumbIndexDist > 0.1) {
                    handleGesture('fist');
                    isPinching = false;
                } else if (fingersDown === 0) {
                    handleGesture('open');
                    isPinching = false;
                } else if (thumbIndexDist < 0.05) {
                    if (!isPinching) {
                        isPinching = true;
                        handleGesture('pinch');
                        handlePinch(landmarks);
                    }
                } else {
                    isPinching = false;
                    if (focusedPhoto) {
                        focusedPhoto.isFocused = false;
                        focusedPhoto.targetScale = 0.3;
                        focusedPhoto = null;
                    }
                    // æœªçŸ¥æ‰‹åŠ¿ä¹Ÿå›é€€åˆ°æ¡æ‹³çŠ¶æ€
                    handleGesture('fist');
                }
            } else {
                // æ— æ‰‹åŠ¿æ—¶å›é€€åˆ°èšåˆçŠ¶æ€
                handleGesture('fist');
                isPinching = false;
                if (focusedPhoto) {
                    focusedPhoto.isFocused = false;
                    focusedPhoto.targetScale = 0.3;
                    focusedPhoto = null;
                }
            }

            requestAnimationFrame(detectHands);
        }

        // éŸ³é¢‘åˆæˆå™¨
        class ChristmasSynth {
            constructor() {
                this.audioContext = null;
                this.oscillators = []; // è·Ÿè¸ªæ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„oscillators
                this.gainNodes = []; // è·Ÿè¸ªæ‰€æœ‰gain nodes
                this.isPlaying = false;
                this.currentTime = 0;
                this.loopTimeout = null; // ä¿å­˜å¾ªç¯å®šæ—¶å™¨ID
            }

            async init() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            playNote(frequency, startTime, duration, type = 'sine') {
                if (!this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = type;
                oscillator.frequency.value = frequency;

                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.1, startTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // è·Ÿè¸ªoscillatorå’ŒgainNodeï¼Œä»¥ä¾¿åœ¨stopæ—¶åœæ­¢å®ƒä»¬
                this.oscillators.push(oscillator);
                this.gainNodes.push(gainNode);

                oscillator.start(startTime);
                oscillator.stop(startTime + duration);
                
                // éŸ³ç¬¦æ’­æ”¾å®Œæˆåè‡ªåŠ¨æ¸…ç†
                oscillator.onended = () => {
                    const oscIndex = this.oscillators.indexOf(oscillator);
                    if (oscIndex > -1) {
                        this.oscillators.splice(oscIndex, 1);
                    }
                    const gainIndex = this.gainNodes.indexOf(gainNode);
                    if (gainIndex > -1) {
                        this.gainNodes.splice(gainIndex, 1);
                    }
                };
            }

            // ã€ŠSnowmanã€‹å®Œæ•´æ—‹å¾‹
            playSnowman() {
                if (!this.audioContext) return;
                
                // å¦‚æœå·²ç»åœ¨æ’­æ”¾ï¼Œä¸é‡å¤å¯åŠ¨
                if (this.isPlaying) {
                    return;
                }

                this.isPlaying = true;
                this.currentTime = this.audioContext.currentTime + 0.1;

                // ã€ŠSnowmanã€‹å®Œæ•´æ—‹å¾‹ - å‚è€ƒåŸæ›²
                const notes = [
                    // ç¬¬ä¸€æ®µä¸»æ—‹å¾‹
                    { freq: 523.25, dur: 0.4 }, // C5
                    { freq: 587.33, dur: 0.4 }, // D5
                    { freq: 659.25, dur: 0.4 }, // E5
                    { freq: 523.25, dur: 0.4 }, // C5
                    { freq: 493.88, dur: 0.4 }, // B4
                    { freq: 440.00, dur: 0.8 }, // A4
                    { freq: 392.00, dur: 0.4 }, // G4
                    { freq: 440.00, dur: 0.4 }, // A4
                    { freq: 493.88, dur: 0.4 }, // B4
                    { freq: 523.25, dur: 0.8 }, // C5
                    // ç¬¬äºŒæ®µ
                    { freq: 440.00, dur: 0.4 }, // A4
                    { freq: 493.88, dur: 0.4 }, // B4
                    { freq: 523.25, dur: 0.4 }, // C5
                    { freq: 587.33, dur: 0.4 }, // D5
                    { freq: 659.25, dur: 0.8 }, // E5
                    { freq: 523.25, dur: 0.4 }, // C5
                    { freq: 493.88, dur: 0.4 }, // B4
                    { freq: 440.00, dur: 0.8 }, // A4
                    // ç¬¬ä¸‰æ®µ
                    { freq: 392.00, dur: 0.4 }, // G4
                    { freq: 440.00, dur: 0.4 }, // A4
                    { freq: 493.88, dur: 0.4 }, // B4
                    { freq: 523.25, dur: 0.8 }, // C5
                    { freq: 440.00, dur: 0.4 }, // A4
                    { freq: 493.88, dur: 0.4 }, // B4
                    { freq: 523.25, dur: 1.2 }, // C5
                    // ç¬¬å››æ®µ - æ‰©å±•
                    { freq: 392.00, dur: 0.4 }, // G4
                    { freq: 440.00, dur: 0.4 }, // A4
                    { freq: 493.88, dur: 0.4 }, // B4
                    { freq: 523.25, dur: 0.4 }, // C5
                    { freq: 587.33, dur: 0.4 }, // D5
                    { freq: 659.25, dur: 0.8 }, // E5
                    { freq: 523.25, dur: 0.4 }, // C5
                    { freq: 493.88, dur: 0.4 }, // B4
                    { freq: 440.00, dur: 0.8 }, // A4
                    // ç¬¬äº”æ®µ - ç»“å°¾
                    { freq: 392.00, dur: 0.4 }, // G4
                    { freq: 440.00, dur: 0.4 }, // A4
                    { freq: 493.88, dur: 0.4 }, // B4
                    { freq: 523.25, dur: 1.0 }, // C5
                ];

                let time = this.currentTime;
                notes.forEach(note => {
                    this.playNote(note.freq, time, note.dur, 'sine');
                    time += note.dur;
                });

                // å¾ªç¯æ’­æ”¾
                const totalDuration = time - this.currentTime;
                // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (this.loopTimeout) {
                    clearTimeout(this.loopTimeout);
                }
                // ä¿å­˜å®šæ—¶å™¨IDï¼Œä»¥ä¾¿åœ¨stopæ—¶æ¸…é™¤
                this.loopTimeout = setTimeout(() => {
                    // åªæœ‰åœ¨ä»ç„¶æ’­æ”¾æ—¶æ‰ç»§ç»­å¾ªç¯
                    if (this.isPlaying && this.audioContext && this.audioContext.state !== 'closed') {
                        // é‡ç½®isPlayingæ ‡å¿—ï¼Œå…è®¸é‡æ–°æ’­æ”¾
                        this.isPlaying = false;
                        this.playSnowman();
                    } else {
                        // å¦‚æœå·²åœæ­¢ï¼Œæ¸…é™¤å®šæ—¶å™¨å¼•ç”¨
                        this.loopTimeout = null;
                    }
                }, Math.max(totalDuration * 1000, 100)); // ç¡®ä¿è‡³å°‘100mså»¶è¿Ÿ
            }

            stop() {
                // å…ˆè®¾ç½®isPlayingä¸ºfalseï¼Œé˜²æ­¢æ–°çš„æ’­æ”¾
                this.isPlaying = false;
                // æ¸…é™¤å¾ªç¯å®šæ—¶å™¨ï¼Œé˜²æ­¢ç»§ç»­æ’­æ”¾
                if (this.loopTimeout) {
                    clearTimeout(this.loopTimeout);
                    this.loopTimeout = null;
                }
                // åœæ­¢æ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„oscillators
                this.oscillators.forEach(osc => {
                    try {
                        osc.stop();
                    } catch (e) {
                        // å¿½ç•¥å·²ç»åœæ­¢çš„oscillatoré”™è¯¯
                    }
                });
                // å¿«é€Ÿæ·¡å‡ºæ‰€æœ‰gain nodes
                if (this.audioContext) {
                    const currentTime = this.audioContext.currentTime;
                    this.gainNodes.forEach(gainNode => {
                        try {
                            gainNode.gain.cancelScheduledValues(currentTime);
                            gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
                            gainNode.gain.linearRampToValueAtTime(0, currentTime + 0.1); // 0.1ç§’æ·¡å‡º
                        } catch (e) {
                            // å¿½ç•¥é”™è¯¯
                        }
                    });
                }
                // æ¸…ç©ºæ•°ç»„
                this.oscillators = [];
                this.gainNodes = [];
            }
        }

        // ä¸Šä¼ ç…§ç‰‡
        function handleFileUpload(event) {
            const files = event.target.files;
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const texture = new THREE.TextureLoader().load(e.target.result);
                        texture.colorSpace = THREE.SRGBColorSpace;

                        // ä¿æŒå›¾ç‰‡åŸå§‹å®½é«˜æ¯” - ç®€åŒ–å¤„ç†
                        const aspectRatio = img.width / img.height;
                        // ä½¿ç”¨å›ºå®šçš„åŸºç¡€å°ºå¯¸ï¼Œä¿æŒå®½é«˜æ¯”
                        const baseSize = 1;
                        const width = baseSize * aspectRatio;
                        const height = baseSize;

                        const geometry = new THREE.PlaneGeometry(width, height);
                        const material = new THREE.MeshBasicMaterial({
                            map: texture,
                            color: 0xcccccc, // é™ä½äº®åº¦ï¼Œä»0xffffffæ”¹ä¸º0xccccccï¼Œé¿å…è¿‡äº®
                            toneMapped: true, // å¯ç”¨è‰²è°ƒæ˜ å°„ï¼Œé¿å…è¿‡äº®
                            transparent: false, // ä¸é€æ˜ï¼Œé¿å…è™šåŒ–
                            opacity: 1.0, // å®Œå…¨ä¸é€æ˜
                            side: THREE.DoubleSide // åŒé¢æ˜¾ç¤º
                        });
                        // è®¾ç½®æè´¨ä¸å‚ä¸bloomæ•ˆæœï¼ˆé€šè¿‡è®¾ç½®emissiveä¸º0ï¼Œä½†MeshBasicMaterialä¸æ”¯æŒemissiveï¼‰
                        // æˆ–è€…é€šè¿‡é™ä½æè´¨çš„äº®åº¦æ¥å‡å°‘bloomå½±å“
                        const mesh = new THREE.Mesh(geometry, material);

                        // åœ¨æ ‘ä¸Šåˆ†å¸ƒç…§ç‰‡ - è·Ÿéšæ ‘çš„ä½ç½®
                        const maxHeight = 12;
                        const baseRadius = 6;
                        const topRadius = 0.05;
                        const treeOffsetY = -5;
                        const t = 0.2 + Math.random() * 0.6; // åˆ†å¸ƒåœ¨æ ‘çš„ä¸­ä¸‹éƒ¨åˆ°ä¸­ä¸Šéƒ¨
                        const treeHeight = t * maxHeight + treeOffsetY;
                        const layerMaxRadius = topRadius + (baseRadius - topRadius) * (1 - t);
                        const angle = Math.random() * Math.PI * 2;
                        const radius = layerMaxRadius * (0.85 + Math.random() * 0.15); // åœ¨æ ‘è¡¨é¢é™„è¿‘
                        
                        mesh.position.set(
                            Math.cos(angle) * radius,
                            treeHeight,
                            Math.sin(angle) * radius
                        );
                        // å¢å¤§ç…§ç‰‡åˆå§‹å¤§å°ï¼Œè®©å®ƒä»¬åœ¨æ ‘ä¸Šæ›´æ˜æ˜¾
                        const initialScale = 0.4; // å‡å°ç¼©ç•¥å›¾å¤§å°
                        mesh.scale.set(initialScale, initialScale, 1);

                        scene.add(mesh);

                        photos.push({
                            mesh,
                            texture,
                            targetScale: initialScale,
                            targetPosition: mesh.position.clone(),
                            isFocused: false,
                            aspectRatio: aspectRatio,
                            isOnTree: true // åˆå§‹å°±åœ¨æ ‘ä¸Š
                        });
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            animateParticles();
            updateSnow();
            updatePhotos();

            composer.render();
        }

        // çª—å£è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // åˆå§‹åŒ–
        async function init() {
            try {
                initScene();
                createMainTree();
                // å½©å¸¦æš‚æ—¶æ³¨é‡Š
                // ribbonSystem = createRibbon();
                createSnowSystem();
                ornamentSystem = createOrnaments();
                // æœ€åæ·»åŠ äº”è§’æ˜Ÿï¼Œç¡®ä¿å®ƒåœ¨æœ€ä¸Šå±‚ï¼Œä¸é®æŒ¡ç²’å­
                starSystem = createStar();

                synth = new ChristmasSynth();
                await synth.init();

                // å°è¯•è‡ªåŠ¨æ’­æ”¾éŸ³ä¹ - ä½¿ç”¨éé˜»å¡æ–¹å¼ï¼Œä¸ç­‰å¾…resumeå®Œæˆ
                synth.audioContext.resume().then(() => {
                    synth.playSnowman();
                    isPlaying = true;
                }).catch((e) => {
                    console.log('éœ€è¦ç”¨æˆ·äº¤äº’æ‰èƒ½æ’­æ”¾éŸ³é¢‘');
                });

                // ç”¨æˆ·äº¤äº’è§£é”éŸ³é¢‘
                let audioUnlocked = false;
                const unlockAudio = async () => {
                    if (!audioUnlocked) {
                        audioUnlocked = true;
                        await synth.audioContext.resume();
                        if (!isPlaying) {
                            synth.playSnowman();
                            isPlaying = true;
                        }
                        document.removeEventListener('click', unlockAudio);
                        document.removeEventListener('touchstart', unlockAudio);
                    }
                };
                document.addEventListener('click', unlockAudio);
                document.addEventListener('touchstart', unlockAudio);

                // éŸ³ä¹æŒ‰é’®
                document.getElementById('btnMusic').addEventListener('click', () => {
                    // æ£€æŸ¥synthçš„isPlayingçŠ¶æ€ï¼ˆè¿™æ˜¯æœ€å‡†ç¡®çš„ï¼‰
                    if (synth.isPlaying) {
                        synth.stop();
                        isPlaying = false; // åŒæ­¥å…¨å±€çŠ¶æ€
                        document.getElementById('btnMusic').textContent = 'ğŸ”‡';
                    } else {
                        synth.playSnowman();
                        isPlaying = true; // åŒæ­¥å…¨å±€çŠ¶æ€
                        document.getElementById('btnMusic').textContent = 'ğŸµ';
                    }
                });

                // ä¸Šä¼ æŒ‰é’®
                document.getElementById('btnUpload').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });
                document.getElementById('file-input').addEventListener('change', handleFileUpload);

                animate();
                window.addEventListener('resize', onWindowResize);

                // éšè—åŠ è½½é¡µ - åœ¨åœºæ™¯åˆå§‹åŒ–å®Œæˆåç«‹å³éšè—ï¼Œä¸ç­‰å¾…MediaPipe
                setTimeout(() => {
                    const loadingOverlay = document.getElementById('loadingOverlay');
                    if (loadingOverlay) {
                        loadingOverlay.classList.add('hidden');
                    }
                }, 500);

                // åˆå§‹åŒ–MediaPipe - åœ¨åå°å¼‚æ­¥æ‰§è¡Œï¼Œä¸é˜»å¡ä¸»æµç¨‹
                initMediaPipe().catch(err => {
                    console.error('MediaPipeåˆå§‹åŒ–å¤±è´¥ï¼ˆéé˜»å¡ï¼‰:', err);
                });
            } catch (e) {
                console.error('Init error:', e);
            }
        }

        init();
    </script>
</body>
</html>
